use hmac::{Hmac, Mac};
use rand_core::OsRng;
use sha2::{Digest, Sha256};
use x25519_dalek::{PublicKey, StaticSecret};

mod test;

struct PrivatePublicKeyPair {
    // In the future, type StaticSecret should be reserved for the server's static and the EphemeralSecret reserved for the ephemeral private key.
    // However, as a quirk of the nTOR protocol, we also need to use StaticSecret for the client's ephemeral private key hence why it is adopted here.
    private_key: Option<StaticSecret>,
    public_key: PublicKey,
}

fn generate_private_public_key_pair() -> PrivatePublicKeyPair {
    let private_key = StaticSecret::random_from_rng(OsRng);
    let public_key = PublicKey::from(&private_key);

    PrivatePublicKeyPair {
        private_key: Some(private_key),
        public_key,
    }
}

struct Client {
    ephemeral_key_pair: PrivatePublicKeyPair,
    shared_secret: Option<Vec<u8>>,
}

struct Server {
    static_key_pair: PrivatePublicKeyPair,
    ephemeral_key_pair: PrivatePublicKeyPair,
    server_id: String,
    shared_secret: Option<Vec<u8>>,
}

struct Certificate {
    public_key: PublicKey,
    server_id: String,
}

// In the paper, the outgoing message is ("ntor", B_id, client_ephemeral_public_key).
struct InitSessionMessage {
    client_ephemeral_public_key: PublicKey,
}

// In the paper, the return message is ("ntor", server_ephemeral_public_key, t_b_hash).
struct InitSessionResponse {
    server_ephemeral_public_key: PublicKey,
    t_b_hash: Vec<u8>,
}

impl Client {
    fn new() -> Self {
        Self {
            ephemeral_key_pair: PrivatePublicKeyPair {
                private_key: None,
                public_key: PublicKey::from([0; 32]),
            },
            shared_secret: None,
        }
    }

    fn initialise_session(&mut self) -> InitSessionMessage {
        self.ephemeral_key_pair = generate_private_public_key_pair();

        InitSessionMessage {
            client_ephemeral_public_key: self.ephemeral_key_pair.public_key,
        }
    }

    // Steps 15 - 20 of the Goldberg 2012 paper.
    fn handle_response_from_server(
        &mut self,
        server_certificate: &Certificate,
        msg: &InitSessionResponse,
    ) -> bool {
        println!("Client:");

        // Step 18: Compute the shared secret.
        let mut buffer: Vec<u8> = Vec::new();

        // ECDH Client private ephemeral * server static public key
        let taken_private_key = self.ephemeral_key_pair.private_key.take().unwrap();
        let mut ecdh_result_1 = taken_private_key
            .diffie_hellman(&msg.server_ephemeral_public_key)
            .to_bytes()
            .to_vec();
        println!("[Debug] ECDH result 1: {:?}", ecdh_result_1);
        buffer.append(&mut ecdh_result_1);

        // ECDH Client private ephemeral * server ephemeral public Key
        let mut ecdh_result_2 = taken_private_key
            .diffie_hellman(&server_certificate.public_key)
            .to_bytes()
            .to_vec();
        println!("[Debug] ECDH result 2: {:?}", ecdh_result_2);
        buffer.append(&mut ecdh_result_2);

        // Server id
        buffer.append(&mut server_certificate.server_id.as_bytes().to_vec());

        // Client ephemeral public
        buffer.append(&mut self.ephemeral_key_pair.public_key.as_bytes().to_vec());

        // Server ephemeral public
        buffer.append(&mut msg.server_ephemeral_public_key.as_bytes().to_vec());

        // "ntor" string identifier
        buffer.append(&mut "ntor".as_bytes().to_vec());

        // Instantiate and run hashing function
        let mut hasher = Sha256::new();
        hasher.update(buffer);
        let sha256_hash = hasher.finalize();
        let sha256_hash: &[u8; 32] = match sha256_hash.as_slice().try_into() {
            Ok(array_ref) => array_ref,
            Err(_) => {
                panic!("Invalid sha256 hash length");
            }
        };

        let secret_key_prime = &sha256_hash[0..16];
        println!("[Debug] Client secret key prime: {:?}", secret_key_prime);

        let secret_key = &sha256_hash[16..];

        // Step 19: Compute HMAC (t_b in the paper)

        let mut buffer: Vec<u8> = Vec::new();
        buffer.append(&mut server_certificate.server_id.as_bytes().to_vec());
        buffer.append(&mut msg.server_ephemeral_public_key.as_bytes().to_vec());
        buffer.append(&mut self.ephemeral_key_pair.public_key.as_bytes().to_vec());
        buffer.append(&mut "ntor".as_bytes().to_vec());
        buffer.append(&mut "server".as_bytes().to_vec());

        let mut hmac_hash = Hmac::<Sha256>::new_from_slice(&buffer).unwrap();
        hmac_hash.update(secret_key_prime);
        let computed_t_b_hash = hmac_hash.finalize().into_bytes().to_vec();

        // assert that computed_t_b_hash equals t_hash generated by server
        if computed_t_b_hash == msg.t_b_hash {
            self.shared_secret = Some(secret_key.to_vec());

            println!("Shared secret:");
            println!("{:?}\n", secret_key);
            true
        } else {
            println!("Failed to verify the shared secret: try again bro.");
            false
        }
    }
}

impl Server {
    fn new(server_id: String) -> Self {
        // In the future, implementations of static and ephemeral key pair generation should differ.
        Self {
            ephemeral_key_pair: PrivatePublicKeyPair {
                private_key: None,
                public_key: PublicKey::from([0; 32]),
            },
            server_id,
            shared_secret: None,
            static_key_pair: generate_private_public_key_pair(),
        }
    }

    fn get_certificate(&self) -> Certificate {
        // Upon implementation and deployment, it's the Service Provider that will create and then upload a certificate to the Layer8 Authentication Server. Likely, Layer8 will also provide the necessary functions to create one for the client.
        Certificate {
            public_key: self.static_key_pair.public_key,
            server_id: self.server_id.clone(),
        }
    }

    fn accept_init_session_request(
        &mut self,
        init_msg: &InitSessionMessage,
    ) -> InitSessionResponse {
        println!("Server:");

        // generate session-specific ephemeral key pair
        self.ephemeral_key_pair = generate_private_public_key_pair();

        let mut buffer: Vec<u8> = Vec::new();
        // client_ephemeral_public^server_ephemeral_private (X^y),
        let taken_private_key = self.ephemeral_key_pair.private_key.take().unwrap();
        let mut ecdh_results_1 = taken_private_key
            .diffie_hellman(&init_msg.client_ephemeral_public_key)
            .to_bytes()
            .to_vec();
        println!("[Debug] ECDH result 1: {:?}", ecdh_results_1);
        buffer.append(&mut ecdh_results_1);

        // client_ephemeral_public^server_static_private (X^b),
        let taken_private_key = self.static_key_pair.private_key.take().unwrap();
        let mut ecdh_results_2 = taken_private_key
            .diffie_hellman(&init_msg.client_ephemeral_public_key)
            .to_bytes()
            .to_vec();
        println!("[Debug] ECDH result 2: {:?}", ecdh_results_2);
        buffer.append(&mut ecdh_results_2);

        // server id
        buffer.append(&mut self.server_id.as_bytes().to_vec());

        // client_ephemeral_public (X)
        buffer.append(&mut init_msg.client_ephemeral_public_key.to_bytes().to_vec());

        // server_ephemeral_public (Y)
        buffer.append(&mut self.ephemeral_key_pair.public_key.to_bytes().to_vec());

        // "ntor"
        buffer.append(&mut "ntor".as_bytes().to_vec());

        // Instantiate sha256 hash function and compute
        let mut hasher = Sha256::new();
        hasher.update(buffer);
        let sha256_hash = hasher.finalize();
        let sha256_hash: &[u8; 32] = match sha256_hash.as_slice().try_into() {
            Ok(array_ref) => array_ref,
            Err(_) => {
                panic!("Invalid sha256 hash length");
            }
        };

        let secret_key_prime = &sha256_hash[0..16];
        let secret_key = &sha256_hash[16..];
        println!("[Debug] Server secret key prime: {:?}", secret_key_prime);

        // Step 12: Compute HMAC (t_b in the paper):
        let mut hmac_key_buffer: Vec<u8> = Vec::new();
        // server id
        hmac_key_buffer.append(&mut self.server_id.as_bytes().to_vec());
        // server_ephemeral_public_key
        hmac_key_buffer.append(&mut self.ephemeral_key_pair.public_key.to_bytes().to_vec());
        // client_ephemeral_public_key
        hmac_key_buffer.append(&mut init_msg.client_ephemeral_public_key.to_bytes().to_vec());
        // "ntor"
        hmac_key_buffer.append(&mut "ntor".as_bytes().to_vec());
        // "server"
        hmac_key_buffer.append(&mut "server".as_bytes().to_vec());

        let mut hmac_hash = Hmac::<Sha256>::new_from_slice(&hmac_key_buffer).unwrap();
        hmac_hash.update(secret_key_prime);
        let t_b_hash = hmac_hash.finalize().into_bytes().to_vec();

        self.shared_secret = Some(secret_key.to_vec());

        println!("Shared secret:");
        println!("{:?}\n", secret_key);

        InitSessionResponse {
            server_ephemeral_public_key: self.ephemeral_key_pair.public_key,
            t_b_hash,
        }
    }
}

fn main() {
    // Create a new client
    let mut client = Client::new();

    // Spin up a server
    let server_id = String::from("my server id");
    let mut server = Server::new(server_id);

    // Client initializes session with the server
    let init_session_msg = client.initialise_session();

    // Server accepts the connection request and processes it
    let init_session_response = server.accept_init_session_request(&init_session_msg);

    // Client processes response from the server and verifies it authenticity
    let success_flag =
        client.handle_response_from_server(&server.get_certificate(), &init_session_response);

    println!("{success_flag}");
}
